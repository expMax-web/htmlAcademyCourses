// Тут нам тоже нужно определить дополнительные параметры, как и в разбиении, чтобы нормально работать с подмассивами
function quickSort(array: number[], left?: number, right?: number) {
  // если мы работаем с целым массивом и нам не передали края сортировки, определим их сами
  left = left ?? 0;
  right = right ?? array.length - 1;

  // разбиваем наш массив на подмассивы вокруг точки поворота
  const pivotIndex = partition(array, left, right);

  // если в левом подмассиве больше одного элемента, то сортируем его
  if (left < pivotIndex - 1) {
    quickSort(array, left, pivotIndex - 1);
  }

  // то же и с правым
  if (pivotIndex < right) {
    quickSort(array, pivotIndex, right);
  }

  return array;
}

function random(min: number, max: number) {
  const interval = max - min; // Интервал, в котором могут находится наши числа
  const shift = min; // Поиск рандомного числа будет начинаться не с нуля, а с min

  return Math.round(Math.random() * interval + shift);
}

// Так как в подразбиениях после рекурсивного вызова сортировки мы будем работать не с целым массивом а его частями, сразу сделаем дополнительные параметры для их определения
function partition(array: number[], left: number, right: number) {
  // Не обращайте внимания на переменные origLeft/origRight: их мы ввели для удобства логирования итераций, в алгоритме они не нужны
  const [origLeft, origRight] = [left, right];
  // Находим значение, вокруг которого будем размещать элементы
  const pivot = array[random(left, right)];

  // как и в бинпоиске, будем сходиться с краев в центр, пока не просмотрим все элементы
  while (left <= right) {
    // Пока слева встречаются только числа меньше поворотного...
    while (array[left] < pivot) {
      // ... просто двигаем левый указатель вправо, ведь с этими числами ничего делать не надо
      left++;
    }

    // Пока справа встречаются только числа больше поворотного...
    while (array[right] > pivot) {
      // ... просто двигаем правый указатель влево, ведь с этими числами ничего делать не надо
      right--;
    }

    // А как только оба указателя показывают на элементы, которые должны быть в противоположных частях И мы всё ещё не сошлись к точке поворота...
    if (left <= right) {
      // ...меняем их местами и не забываем двигать оба указателя, так как теперь оба числа на своём месте
      [array[left], array[right]] = [array[right], array[left]];
      left++;
      right--;
    }
  }

  // Возвращаем место, где оказался элемент, равный нашей точке поворота
  return left;
}

quickSort([56, 87, 18, 92, 42, 31, 44, 82, 36, 91]);
